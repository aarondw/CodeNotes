[TOC]
# 复杂度分析
数据结构和算法解决的就是快和省的问题，即让代码运行的更快，又更节省存储空间。执行效率是算法的一个重要的考量指标。这个指标就是：时间、空间复杂度

## 时间复杂度 
代码执行时间随数据规模增长的变化趋势，简称时间复杂度。

### 大O复杂度表示法
T(n)=O(f(n))

T(n) 它表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。T(n)和f(n)成正比，所以大O时间复杂度并不具体表示代码真正执行的时间，它表示一个趋势，这个趋势就是是表示代码执行时间随数据规模增长的变化趋势。

既然指的的趋势，我们通常会忽略掉公式中的常量、低阶、系数，虽然他们对代码的执行时间有很大影响，但是他们并不左右增长趋势，所以是忽略掉他们的。

### 几种常见的复杂度量级


![](https://user-gold-cdn.xitu.io/2019/11/17/16e79de40faede57?w=781&h=969&f=png&s=97195)

#### 1.O(1)

是常量级复杂度的一种表示方法，并不是只执行了一行代码，而是表示代码的执行的时间不随n的增大而增长，比如下面这段代码，即便有3行，它的时间复杂度也是O(1)，而不是O(3)，这样的代码哪怕有n行，其时间复杂度也是O(1)，只是常量级时间复杂度的一种表示方法。


```
int i = 1;
int j = 6;
int sum = i + j;
```

#### 2.O(logn)、O(nlogn)
这个叫对数阶时间复杂度，下面这段代码执行了2的x次方，结果是n，x=log₂n，所以这段代码的时间复杂度是O(log₂n)
```
int i = 1;
while(i <= n) {
    i = i * 2;
}
```
### 最好、最坏情况时间复杂度
  如果在一个长度为n的数组中寻找一个已知元素x，无非有以下几种可能。
* 数组中不存在该元素，那我们就需要循环遍历整个数组，这个时候，时间复杂度就是O(n)
* 存在该元素，x可能存在现在数组中的任意位置。如果第一个元素正好是x，那么剩下的n-1个元素就不用遍历寻找了，那此时的时间复杂度就是O(1)

我们可以看到，在不同情况下，时间复杂度就是不同的。这个时候需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。

前两个在我刚才举的例子中已经很明显的可以看到了，现在看一下平均时间复杂度

### 平均时间复杂度

我们知道，要查找的x元素，要么在数组中，要么不在数组中，此时的概率是1/2。数据出现在0~n-1这n个位置的概率也是一样的，为1/n。所以此时要查找的是数据出现的概率就是1/(2n)

那么此平均时间复杂度的过程就变成了这样：


```
1 * 1/2n + 2 * 1/2n + ... + n * 1/2n + n * 1/2= (3n+1)/4
```

去掉系数和常量，这段代码的平均时间复杂度仍然是O(n)

### 均摊时间复杂度

均摊时间复杂度是一种特殊的平均时间复杂度。
其大致思路就是先会出现n-1中O(1)的情况，才会出现O(n)的情况，比如x元素，查找分为n中情况，每次情况的时间复杂度是O(1)，还有就是x不存在该数组中，这个时候的时间复杂度就是O(n)。把耗时比较多的这次操作，均摊到前面n-1次耗时少的操作上，均摊一下，这一组连续的操作的均摊时间复杂度就是O(1)。

## 空间复杂度

空间复杂度指的就是算法的存储空间与数据规模之间的增长关系。

指的是一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。


```
void print(int n){
    int i = 0;   //我们申请了一个空间
    int[] arr = new int[n];   //申请了一个大小为n的int类形数组
    
    for(i;i < n; ++i){
        a[i] = i * 2;
    }
    
    //输出数组 省略。。
}
```
变量i，因为他是常量阶，跟数据规模n没有关系，所以我们可以忽略。第三行申请了一个大小为n的数组，所以整段代码的空间复杂度就是O(n)

**复杂度也叫做渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，越高阶复杂度的算法，执行效率越低（如图）。**


![](https://user-gold-cdn.xitu.io/2019/11/18/16e7ed65bffab8d0?w=464&h=275&f=png&s=11864)

# 数据结构

## 线性表
线性表就是数据排成一条线一样的结构。每个线性表上的数据最多只有前后两个方向。比如：数组、链表、队列、栈等

### 数组
数组是我们比较常用的数据结构，存储是相同类型的数据，并且是连续的内存空间。数组支持随机访问，根据首地址和下标，通过寻址公式（a[k]_address = base_address + k * type_size）就能直接计算出对应的内存地址，根据下标随机访问的时间复杂度为O(1)。但是，数组为了保持内存数据的连续性，会导致插入、删除两个操作比较低效，因为有可能牵扯到数据的移位。

如果插入到末尾，那时间复杂度为O(1),如果插入到首位，那需要向后挪位n次，此时时间复杂度就是O(n)；平均复杂度就是O(n)。

如果没有特殊要求下，将某个数据插入到第n个位置，为了避免大规模的数据搬移，我们可以直接将第n位的数据搬迁到最后，把新的元素直接放入到第n个位置。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给他，导致内存溢出。如果声明过小，则可能出现不够用的情况。

### 链表
链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。常见的链表结构分别是：单链表、双向链表和循环链表。

#### 单链表
我们把内存块成为链表的“结点”。为了将所有的结点串起来，每个链表的结点处理存储数据之外，还需要记录链上的下一个结点的地址。

与数组一样，链表也支持数据的查找、插入和删除操作

因为链表的存储空间本身就不是连续性的，所以我们在插入和删除一个数据是非常快速的，因为我们只需要考虑相邻结点的指针变化，对应的时间复杂度是O(1)。查找则需要根据指针一个结点一个结点的依次遍历，直到找到相应的结点。

#### 双向链表
顾名思义，双向列表的每个结点上存储着两个指针，一个指向前面，一个指向后面的地址。所以相同多的数据，双向链表占用跟多的内存空间，但支持了双向遍历，更加灵活一些。

#### 循环列表
是一个特殊的单链表，其不同，是链表的最后一个元素指针指向了首位元素，而不是指向了 null。

#### 双向循环列表
双向链表和循环列表合并在一起就是双向循环列表了。

**由此可见，链表相对于数组而言，内存消耗会翻倍，因为链表存储的不止有数据，还有指向下一个元素的指针。链表更适合于插入、删除操作频繁的场景，而查询的时间复杂度则较高。如何选择使用数据或者是链表，看你在空间和时间上怎么取舍了。**

### 栈
栈是一种操作受限的数据结构，只有入栈和出栈两个操作。后进先出是它的最大特点。栈可以通过数据和链表来实现，不管通过哪一种方式实现，入栈和出栈的时间复杂度都是O(1)。

### 队列
队列最大的特点就是先进先出，主要操作是入队和出队。跟栈一样，可以通过数据和链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在用数组实现的时候，会出现数据迁移的问题，我们就需要像环一样的循环队列。

要想写出像环一样没有bug的循环队列，关键要确定好队空和队满的判断条件。

阻塞队列、并发队列，底层都是这种数据结构，只不过附加了一些其他功能。阻塞队列就是入队、出队操作会出现阻塞，并发队列就是队列的多线程安全。

### 递归

只要满足了三个条件，就可以用递归来解决。
1. 一个问题的解可以分解为几个问题的小解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写递归公式，然后在推敲终止条件，最后翻译成代码。

编写递归代码的关键是，只要遇到递归，就抽象成一个递归公式，不要试图用人脑分解递归的每个步骤，要屏蔽到递归细节，这样子理解起来就简单多了。

递归代码要注意一下几点
1. 要警惕堆栈溢出
    可以通过代码中限制递归调用的最大深度的方式来解决这个问题，比如调用到达一定深度一样，就不继续往下递归了，直接返回错误。
2. 要警惕重复计算
    为了避免重复计算，可以通过一个数据结构比如散列表，来保存求解过的f(k)。当递归调用到f(k)的时候，先看下是否求解过，如果是，则直接从散列表中取值返回，不需要重复计算。

递归调试，我们可以通过打印日志和结合条件断点进行调试

## 排序
**如何分析一个“排序算法”**

* 排序算法的执行效率
  
    最好情况、最坏情况、平均时间复杂度，有些排序算法会区分，为了好对比，我们最好做一下区分，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的。我们要知道排序算法在不同数据下的性能表现。
    
    时间复杂度的系数、常数、低阶

    比较次数和交换（或移动）次数
* 排序算法的内存消耗
  
    通过空间复杂度来很衡量，看是否是原地排序，就是特指空间复杂度为O(1)的排序算法

* 排序算法的稳定性
  
    稳定性，就是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

### O(n^2)
#### 冒泡排序